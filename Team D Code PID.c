#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           backLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightFront,    tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*******************************************************************/
/* Imports the Debuggar Window,allowing for values to be displayed */
/* while the Robot is running																			 */
/*  !!!!!  MUST HAVE THE USB -> CONTROLLER ADAPTER TO WORK  !!!!!  */
/*******************************************************************/
#pragma platform(VEX2)

#pragma DebuggerWindows("DebugStream")

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

// PID using optical shaft encoder
//
// Shaft encoder has 360 pulses per revolution
//



/**********************************/
/* ------------------------------ */
/* -----------  VOCAB  ---------- */
/* ------------------------------ */
/**********************************/

/*
 * PID: Preportional Integral Derivative
 * Used to move the motors until the desired position has been reached
 */

//Setpoint: The desired ditance
//Error: Desired distance - current distance
//Ticks: value given off by encoders to track distance
//Constant: Value that remains the same



/*************************/
/* ----- CONSTANTS ----- */
/*************************/

#define PID_SENSOR_INDEX_L		leftEncoder
#define PID_SENSOR_INDEX_R    rightEncoder
#define PID_SENSOR_SCALE      1

#define PID_MOTOR_INDEX_L			leftFront
#define PID_MOTOR_INDEX_R     rightFront
#define PID_MOTOR_SCALE       -1

#define PID_DRIVE_MAX       120
#define PID_DRIVE_MIN     (-120)

#define PID_INTEGRAL_LIMIT  50


/********************/
/* -- PID VALUES -- */
/********************/

//"K" tells us it's a constant value, and should not be changed insidee the code
float  pid_Kp = 0.5;
float  pid_Ki = 0.00;
float  pid_Kd = 0.0;

int pidRunTimes = 0;

static int   pidRunning = 1;
static float pidRequestedValueRight;
static float pidRequestedValueLeft;

bool pidTaskEnded;

/********************************/
/* ---------------------------- */
/* --- USER CONTROL METHODS --- */
/* ---------------------------- */
/********************************/

//Sets the set point on the encoders by inches
//In goes # of inches, out comes encoder value
void setDriveDistance(float distRight, float distLeft) {
	//Sets the setpoint on the encoder
	pidRequestedValueRight = distRight * 585;
	pidRequestedValueLeft  = distLeft  * 585;
}

//Sets the set point on the encoders by rotations
//In goes # of rotations, out comes encoder value
void setDriveRotation(float rotationsRight, float rotationsLeft) {
	//Sets the setpoint on the encoder
	pidRequestedValueRight = (rotationsRight * 12.4) * 53.5;
	pidRequestedValueLeft  = (rotationsLeft  * 12.4) * 53.5;
}





/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task pidController() {
	float  pidSensorCurrentValueRight;
	float  pidSensorCurrentValueLeft;

	float  pidErrorRight;
	float  pidErrorLeft;

	float  pidLastErrorRight;
	float  pidLastErrorLeft;

	float  pidIntegralRight;
	float  pidIntegralLeft;

	float  pidDerivativeRight;
	float  pidDerivativeLeft;

	float  pidDriveRight;
	float  pidDriveLeft;

	// If we are using an encoder then clear it
	if( SensorType[ PID_SENSOR_INDEX_R ] == sensorQuadEncoderOnI2CPort &&
		SensorType[ PID_SENSOR_INDEX_L ] == sensorQuadEncoderOnI2CPort) {
		SensorValue[ PID_SENSOR_INDEX_R ] = 0;
		SensorValue[ PID_MOTOR_INDEX_L ] = 0;
	}

	// Init the variables
	pidLastErrorRight = 0;
	pidLastErrorLeft  = 0;

	pidIntegralRight  = 0;
	pidIntegralLeft   = 0;

	pidTaskEnded = false;

	while( true ) {
		// Is PID control active ?
		if( pidRunning ) {
			// Read the sensor value and scale
			pidSensorCurrentValueRight = SensorValue[ PID_SENSOR_INDEX_R ] * PID_SENSOR_SCALE;
			pidSensorCurrentValueLeft = -1 * (SensorValue[ PID_SENSOR_INDEX_L ] * PID_SENSOR_SCALE);

			// calculate error
			pidErrorRight = pidSensorCurrentValueRight - pidRequestedValueRight;
			pidErrorLeft  = pidSensorCurrentValueLeft  - pidRequestedValueLeft;

			// integral - if Ki is not 0
			if( pid_Ki != 0 ) {
				// If we are inside controlable window then integrate the error
				if( abs(pidErrorRight) < PID_INTEGRAL_LIMIT ) {
					pidIntegralRight += pidErrorRight;
					} else {
					pidIntegralRight = 0;
				}
				} else {
				pidIntegralRight = 0;
			}

			if( pid_Ki != 0 ) {
				// If we are inside controlable window then integrate the error
				if( abs(pidErrorLeft) < PID_INTEGRAL_LIMIT ) {
					pidIntegralLeft += pidErrorLeft;
					} else {
					pidIntegralLeft = 0;
				}
				} else {
				pidIntegralLeft = 0;
			}

			// calculate the derivative
			pidDerivativeRight = pidErrorRight - pidLastErrorRight;
			pidLastErrorRight  = pidErrorRight;

			pidDerivativeLeft = pidErrorLeft - pidLastErrorLeft;
			pidLastErrorLeft  = pidErrorLeft;


			// calculate drive
			pidDriveRight = (pid_Kp * pidErrorRight) + (pid_Ki * pidIntegralRight) + (pid_Kd * pidDerivativeRight);
			pidDriveLeft = (pid_Kp * pidErrorLeft) + (pid_Ki * pidIntegralLeft) + (pid_Kd * pidDerivativeLeft);

			// limit drive
			if( pidDriveRight > PID_DRIVE_MAX )
				pidDriveRight = PID_DRIVE_MAX;
			if( pidDriveRight < PID_DRIVE_MIN )
				pidDriveRight = PID_DRIVE_MIN;

			if( pidDriveLeft > PID_DRIVE_MAX )
				pidDriveLeft = PID_DRIVE_MAX;
			if( pidDriveLeft < PID_DRIVE_MIN )
				pidDriveLeft = PID_DRIVE_MIN;


			// send to motor
			//sets speed of the motor
			motor[ PID_MOTOR_INDEX_R ] = pidDriveRight * PID_MOTOR_SCALE;
			motor[ backRight] = pidDriveRight * PID_MOTOR_SCALE;

			motor[ PID_MOTOR_INDEX_L ] = pidDriveLeft * PID_MOTOR_SCALE;
			motor[ backLeft] = pidDriveLeft * PID_MOTOR_SCALE;
			} else {
			// clear all
			pidErrorRight      = 0;
			pidLastErrorRight  = 0;
			pidIntegralRight   = 0;
			pidDerivativeRight = 0;

			pidErrorLeft       = 0;
			pidLastErrorLeft   = 0;
			pidIntegralLeft    = 0;
			pidDerivativeLeft  = 0;

			pidTaskEnded = true;
			pidRunTimes += 1;

			motor[ PID_MOTOR_INDEX_R ] = 0;
			motor[ PID_MOTOR_INDEX_L ] = 0;
		}

		writeDebugStreamLine("Right Encoder: %d", SensorValue(PID_SENSOR_INDEX_R));
		writeDebugStreamLine("Left Encoder: %d", SensorValue(PID_SENSOR_INDEX_L));

		/*
		if(SensorValue(PID_SENSOR_INDEX_R) >= pidRequestedValueRight - 50 ||
			SensorValue(PID_SENSOR_INDEX_R) <= pidRequestedValueRight + 50) {
				stopTask(pidController);
			}*/
		// Run at 50Hz
		wait1Msec( 25 );
	}
}

/*******************************************/
/*-----------------------------------------*/
/*--------  AUTON COMMAND METHODS  --------*/
/*-----------------------------------------*/
/*******************************************/


/**
* desiredDistRight: distance in feet on the right side of the chassis
* desiredDistLeft: distance in feet on the left side of the chassis
*/
void driveForwardToPosition(float desiredDistRight, float desiredDistLeft) {
	//int currentDist = 0;
	setDriveDistance(desiredDistRight, desiredDistLeft);

	startTask(pidController);
}


/**
* angle: the angle the robot will turn to
* dist: distance in ticks which the robot will move
* encoderSide: the side of the chassis that is read
*(Read left when turning right, read right when turning left)
*/
void driveToAngle(float angle, float dist, bool encoderSide) {
	//Need gyro inorder to accurately judge the angle

}


void pre_auton() {

	bStopTasksBetweenModes = true;
	//used for setting values before auton
}



task autonomous() {

while(true) {
	driveForwardToPosition(5, 5);
	if(pidTaskEnded && pidRunTimes == 1) {
	writeDebugStreamLine("COMMAND --- 1 --- FINISHED");
	driveForwardToPosition(2, 2);
} else if(pidTaskEnded && pidRunTimes == 2) {
	writeDebugStreamLine("COMMAND --- 2 --- FINISHED");
	writeDebugStreamLine("ENDED");
}


}

}

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  main task                                                                  */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task usercontrol() {

	while( true ) {
		motor[rightFront] = vexRT[Ch3];
		motor[backRight] = vexRT[Ch3];
		motor[leftFront] = vexRT[Ch2];
		motor[backLeft] = vexRT[Ch2];
		if (vexRT[Btn7U] == 1){
			startTask(autonomous);
			stopTask(usercontrol);
		}


	}

}













/******************************/
/*----------------------------*/
/*-------- TEST CODE ---------*/
/*----------------------------*/
/******************************/


/*-- used for driveForwardToPosition method --*/
/*
	while(true) {
		if(encoderSide) {
			currentDist = SensorValue(PID_SENSOR_INDEX_R);
			} else if(!encoderSide) {
			currentDist = SensorValue(PID_SENSOR_INDEX_L);
		}

		// Prints the encoder values
		writeDebugStreamLine("Right Encoder: %d", SensorValue(PID_SENSOR_INDEX_R));
		writeDebugStreamLine("Left Encoder: %d", SensorValue(PID_SENSOR_INDEX_L));



			if(currentDist == desiredDist || currentDist >= desiredDist - 40) {
				break;
		}
		wait1Msec(50);
	}
	*/

	/*---------------------------------------------*/
