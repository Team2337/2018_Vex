#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  autonColorChooser, sensorTouch)
#pragma config(Sensor, dgtl2,  autonTileChooser, sensorTouch)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftFront,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           elevator,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           shooterRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           shooterLeft,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           flingerThinger, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*******************************************************************/
/* Imports the Debuggar Window,allowing for values to be displayed */
/* while the Robot is running																			 */
/*  !!!!!  MUST HAVE THE USB -> CONTROLLER ADAPTER TO WORK  !!!!!  */
/*******************************************************************/
#pragma platform(VEX2)

#pragma DebuggerWindows("DebugStream")

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

// PID using optical shaft encoder
//
// Shaft encoder has 360 pulses per revolution
//



/****************************************/
/* ------------------------------------ */
/* -----------  DEFINITIONS  ---------- */
/* ------------------------------------ */
/****************************************/

/*
* PID: Preportional Integral Derivative
* Used to move the motors until the desired position has been reached
*/

//Setpoint: The desired ditance
//Error: Desired distance - current distance
//Ticks: value given off by encoders to track distance
//Constant: Value that remains the same



/*************************/
/* --------------------- */
/* ----- CONSTANTS ----- */
/* --------------------- */
/*************************/

//Chassis PID Encoders
#define PID_SENSOR_INDEX_L		leftEncoder
#define PID_SENSOR_INDEX_R    rightEncoder
#define PID_SENSOR_SCALE      1

//Chassis PID Motors
//Are able to change depending on the motors you want to use for the PID
#define PID_MOTOR_INDEX_L			leftFront
#define PID_MOTOR_INDEX_R     rightFront
#define PID_MOTOR_SCALE       -1

#define PID_DRIVE_MAX       120
#define PID_DRIVE_MIN     (-120)

#define PID_INTEGRAL_LIMIT  50

//Claw Motors
#define CLAW_MOTOR_INDEX		claw

//Gyro Sensor
#define GYRO_SENSOR					gyro

/**********************/
/* ------------------ */
/* --- PID VALUES --- */
/* ------------------ */
/**********************/

//"K" tells us it's a constant value, and should not be changed inside the code
float  pid_Kp = 0.5;
float  pid_Ki = 0.00;
float  pid_Kd = 0.0;
float gyroAngle = 0;

int pidRunTimes = 0;
int lastAutonTask = 0;
//Used to ensure that the auton stops after the given number of "commands"
int totalAutonCommands = 0;

//static int   pidRunning = 1;
static float pidRequestedValueRight;
static float pidRequestedValueLeft;

//Gyro values
//static float degrees = 0;

static string armPosition = "DOWN";

bool pidTaskEnded;

/*************************/
/* --------------------- */
/* --- AUTON METHODS --- */
/* --------------------- */
/*************************/

//Sets the set point on the encoders by inches
//In goes # of inches, out comes encoder value
void setDriveDistance_Inch(float dist) {
	//commandTimes++;
	//Sets the setpoint on the encoder
	pidRequestedValueRight = dist * 585;
	pidRequestedValueLeft  = dist * 585;
}

/**
* Sets the distance based off of the tiles
* !!! Constant multiplied by needs to be tuned for each field !!!
* dist: distance in # of tiles
*/
void setDriveDistance_Tile(float dist) {
	pidRequestedValueLeft  = dist * 1;
	pidRequestedValueRight = dist * 1;
}

//Sets the set point on the encoders by rotations
//In goes # of rotations, out comes encoder value
void setDriveRotation(float rotationsRight, float rotationsLeft) {
	//Sets the setpoint on the encoder
	pidRequestedValueRight = (rotationsRight * 12.4) * 53.5;
	pidRequestedValueLeft  = (rotationsLeft  * 12.4) * 53.5;
}

/**
* Changes the desired degree into the correct amount of ENCODER ticks
* distRight: the distance on the right wheel
* distLeft:  the distance on the left  wheel
*/
void setRotationDegreeWithEncoders(float distRight, float distLeft) {
	//Sets the setpoint on the encoder
	//5,5 = 180 //Need to change later
	pidRequestedValueRight = distRight * 585;
	pidRequestedValueLeft  = distLeft  * -585;
}

/**
* Changes the desired degree into the correct amount of ticks
* Can change if needed
*/
int setRotationDegreeGyro(float degree) {
	return gyroAngle = degree * 10;
}

/**
*	Turns the robot to a specific angle using the gyro
*/
void driveToAngle(float degree, int speed, float commandNumber) {
	degree = setRotationDegreeGyro(degree);
	//Used to multiply the speed by a + or - 1 to determine the direction
	int direction = degrees / abs(degrees);
	if(lastAutonTask < commandNumber) {
		while(SensorValue[GYRO_SENSOR] < degrees) {
			motor[rightFront] = -speed * direction;
			motor[leftFront]  = speed * direction;
			motor[backRight]  = -speed * direction;
			motor[backLeft]   = speed * direction;
			writeDebugStreamLine("Gyro Ticks: %d", SensorValue[GYRO_SENSOR]);
		}
		lastAutonTask ++;
	}
}


/***********************************/
/* ------------------------------- */
/* --- Simple Movement Methods --- */
/* ------------------------------- */
/***********************************/

/**
* Drives the chassis motors forward for the given time
* speed: 120 -> -120
* time: milliseconds
*/
void driveForwardForTime(int speed, int time) {
	motor[rightFront] = speed;
	motor[leftFront]  = speed;
	motor[backRight]  = speed;
	motor[backLeft]   = speed;
	wait1Msec(time);
	motor[rightFront] = 0;
	motor[leftFront]  = 0;
	motor[backRight]  = 0;
	motor[backLeft]   = 0;
}

/**
* speed: 120 -> -120
* time: milliseconds
*/
void turnForTime(int speed, int time) {
	motor[rightFront] = -speed;
	motor[leftFront]  = speed;
	motor[backRight]  = -speed;
	motor[backLeft]   = speed;
	wait1Msec(time);
	motor[rightFront] = 0;
	motor[leftFront]  = 0;
	motor[backRight]  = 0;
	motor[backLeft]   = 0;
}

/**
* Stops all motors on the chassis
*/
void stopDrive() {
	motor[rightFront] = 0;
	motor[leftFront]  = 0;
	motor[backRight]  = 0;
	motor[backLeft]   = 0;
}


/*------------------------------------------------------------------------------*/
/*                                                                              */
/*  pid control task                                                            */
/*																																						  */
/*	-	This task runs a PID function that dynamically changes the speed of the   */
/*		motors depending on how far away the desired distance is from the current */
/*		encoder reading. 																												  */
/*																																						  */
/*	-	It is set up to be able to account for a left and right side encoder.     */
/*	-	The motors and ports are defined as variables to allow for the user to 	  */
/*		change the desired motors, meaning that this task can be used for 			  */
/*		multiple systems at once.																								  */
/*                                                                              */
/*------------------------------------------------------------------------------*/

task pidController() {
	float  pidSensorCurrentValueRight;
	float  pidSensorCurrentValueLeft;

	float  pidErrorRight;
	float  pidErrorLeft;

	float  pidLastErrorRight;
	float  pidLastErrorLeft;

	float  pidIntegralRight;
	float  pidIntegralLeft;

	float  pidDerivativeRight;
	float  pidDerivativeLeft;

	float  pidDriveRight;
	float  pidDriveLeft;

	stopTask(autonomous);

	// If we are using an encoder then clear it
	if(SensorType[ PID_SENSOR_INDEX_R ] == sensorQuadEncoderOnI2CPort &&
		SensorType[ PID_SENSOR_INDEX_L ] == sensorQuadEncoderOnI2CPort) {
		SensorValue[ PID_SENSOR_INDEX_R ] = 0;
		SensorValue[ PID_MOTOR_INDEX_L ]  = 0;
	}

	// Init the variables
	pidLastErrorRight = 0;
	pidLastErrorLeft  = 0;

	pidIntegralRight  = 0;
	pidIntegralLeft   = 0;

	pidTaskEnded = false;


	while((SensorValue(PID_SENSOR_INDEX_R) >= (pidRequestedValueRight - 50)) ||
		(SensorValue(PID_SENSOR_INDEX_R) <= (pidRequestedValueRight + 50))) {
		// Is PID control active ?
		//Left is negative right is positive
		if( !(SensorValue[ PID_SENSOR_INDEX_R ] > ((abs(pidRequestedValueRight)) - 40))
			|| !(SensorValue[ PID_SENSOR_INDEX_R ] < ((abs(pidRequestedValueRight)) + 40))) {
			// Read the sensor value and scale
			pidSensorCurrentValueRight = -1 * (SensorValue[ PID_SENSOR_INDEX_R ] * PID_SENSOR_SCALE);
			pidSensorCurrentValueLeft = SensorValue[ PID_SENSOR_INDEX_L ] * PID_SENSOR_SCALE;


			// calculate error
			pidErrorRight = pidSensorCurrentValueRight - pidRequestedValueRight;
			pidErrorLeft  = pidSensorCurrentValueLeft  - pidRequestedValueLeft;

			// integral - if Ki is not 0
			if( pid_Ki != 0 ) {
				// If we are inside controlable window then integrate the error
				if( abs(pidErrorRight) < PID_INTEGRAL_LIMIT ) {
					pidIntegralRight += pidErrorRight;
					} else {
					pidIntegralRight = 0;
				}
				} else {
				pidIntegralRight = 0;
			}

			if( pid_Ki != 0 ) {
				// If we are inside controlable window then integrate the error
				if( abs(pidErrorLeft) < PID_INTEGRAL_LIMIT ) {
					pidIntegralLeft += pidErrorLeft;
					} else {
					pidIntegralLeft = 0;
				}
				} else {
				pidIntegralLeft = 0;
			}

			// calculate the derivative
			pidDerivativeRight = pidErrorRight - pidLastErrorRight;
			pidLastErrorRight  = pidErrorRight;

			pidDerivativeLeft = pidErrorLeft - pidLastErrorLeft;
			pidLastErrorLeft  = pidErrorLeft;


			// calculate drive
			pidDriveRight = (pid_Kp * pidErrorRight) + (pid_Ki * pidIntegralRight) + (pid_Kd * pidDerivativeRight);
			pidDriveLeft = (pid_Kp * pidErrorLeft) + (pid_Ki * pidIntegralLeft) + (pid_Kd * pidDerivativeLeft);

			// limit drive
			if( pidDriveRight > PID_DRIVE_MAX )
				pidDriveRight = PID_DRIVE_MAX;
			if( pidDriveRight < PID_DRIVE_MIN )
				pidDriveRight = PID_DRIVE_MIN;

			if( pidDriveLeft > PID_DRIVE_MAX )
				pidDriveLeft = PID_DRIVE_MAX;
			if( pidDriveLeft < PID_DRIVE_MIN )
				pidDriveLeft = PID_DRIVE_MIN;


			// send to motor
			//sets speed of the motor
			motor[ PID_MOTOR_INDEX_R ] = pidDriveRight * PID_MOTOR_SCALE;
			motor[ backRight] = pidDriveRight * PID_MOTOR_SCALE;

			motor[ PID_MOTOR_INDEX_L ] = pidDriveLeft * PID_MOTOR_SCALE;
			motor[ backLeft] = pidDriveLeft * PID_MOTOR_SCALE;
			} else {
			// clear all
			pidErrorRight      = 0;
			pidLastErrorRight  = 0;
			pidIntegralRight   = 0;
			pidDerivativeRight = 0;

			pidErrorLeft       = 0;
			pidLastErrorLeft   = 0;
			pidIntegralLeft    = 0;
			pidDerivativeLeft  = 0;

			pidTaskEnded = true;
			pidRunTimes ++;

			motor[ PID_MOTOR_INDEX_R ] = 0;
			motor[ PID_MOTOR_INDEX_L ] = 0;

			//Ends the task and prepares the next command
			writeDebugStreamLine("COMMAND - FINISHED");
			lastAutonTask ++;
			stopTask(pidController);
		}

		writeDebugStreamLine("Right Encoder: %d", SensorValue(PID_SENSOR_INDEX_R));
		writeDebugStreamLine("Left Encoder: %d", SensorValue(PID_SENSOR_INDEX_L));

		/*
		if(SensorValue(PID_SENSOR_INDEX_R) >= pidRequestedValueRight - 50 ||
		SensorValue(PID_SENSOR_INDEX_R) <= pidRequestedValueRight + 50) {
		stopTask(pidController);
		}*/
		// Run at 50Hz
		wait1Msec( 25 );
	}

	//Code after the while loop has been exited
	writeDebugStreamLine("COMMAND - FINISHED");
	lastAutonTask ++;
	stopTask(pidController);
}


/*******************************************/
/* --------------------------------------- */
/* -------  AUTON COMMAND METHODS  ------- */
/* --------------------------------------- */
/*******************************************/


/**
* desiredDist: distance in tiles on the right side of the chassis
* reset: true if you want to reset the encoders before moving
*/
void driveForwardToPosition(float desiredDist, bool reset, int commandNumber) {
	if(lastAutonTask < commandNumber) {
		//sets the encoders to zero
		//may change for the future to provide more accurate headings.
		if(reset) {
			SensorValue[ PID_SENSOR_INDEX_R ] = 0;
			SensorValue[ PID_MOTOR_INDEX_L ] = 0;
		}

		setDriveDistance_Tile(desiredDist);
		//setDriveDistance_Inch(desiredDist);

		startTask(pidController);
	}
}


/***********************/
/* ------------------- */
/* --- Auton Tasks --- */
/* ------------------- */
/***********************/

task mainAutoBlue() {
	//Regular Auto
	/*
	motor[rightFront] = 120;
	motor[backRight] = 120;
	motor[leftFront] = 120;
	motor[backLeft] = 120;
	wait1Msec(300);
	motor[rightFront] = 0;
	motor[backRight] = 0;
	motor[leftFront] = 0;
	motor[backLeft] = 0;
	motor[shooterRight] = 120;
	motor[shooterLeft]  = 120;
	wait1Msec(2650);
	motor[shooterRight] = 0;
	motor[shooterLeft]  = 0;
	motor[rightFront] = 120;
	motor[backRight] = 120;
	motor[leftFront] = 90;
	motor[backLeft] = 90;
	wait1Msec(4000);
	motor[rightFront] = 0;
	motor[backRight] = 0;
	motor[leftFront] = 0;
	motor[backLeft] = 0;
	*/

	driveForwardForTime(120, 300);
	driveForwardForTime(120, 2650);

}

task mainAutoRed() {
	motor[rightFront] = 120;
	motor[backRight] = 120;
	motor[leftFront] = 120;
	motor[backLeft] = 120;
	wait1Msec(300);
	motor[rightFront] = 0;
	motor[backRight] = 0;
	motor[leftFront] = 0;
	motor[backLeft] = 0;
	motor[shooterRight] = 120;
	motor[shooterLeft]  = 120;
	wait1Msec(2650);
	motor[shooterRight] = 0;
	motor[shooterLeft]  = 0;
	motor[rightFront] = 120;
	motor[backRight] = 120;
	motor[leftFront] = -120;
	motor[backLeft] = -120;
	wait1Msec(125);
	motor[rightFront] = 120;
	motor[backRight] = 120;
	motor[leftFront] = 120;
	motor[backLeft] = 120;
	wait1Msec(4000);
	motor[rightFront] = 0;
	motor[backRight] = 0;
	motor[leftFront] = 0;
	motor[backLeft] = 0;
	startTask(usercontrol);
}

task coopAutoBlue() {
	/*
	driveForwardForTime(120, 300);
	wait1Msec(300);
	motor[shooterLeft] = 120;
	motor[shooterRight] = 120;
	driveForwardForTime(120, 2650);
	wait1Msec(2650);
	motor[shooterLeft] = 0;
	motor[shooterRight] = 0;
	driveForwardForTime(-120, 1000);
	wait1Msec(1000);
	turnForTime(-120, 500);
	wait1Msec(500);
	driveForwardForTime(-120, 3000);
	motor[flingerThinger] = 120;
	wait1Msec(1000);
	motor[flingerThinger] = 0;
	wait1Msec(2000);
	stopDrive();
	*/

	motor[rightFront] = 120;
	motor[backRight] = 120;
	motor[leftFront] = 120;
	motor[backLeft] = 120;
	wait1Msec(300);
	motor[rightFront] = 0;
	motor[backRight] = 0;
	motor[leftFront] = 0;
	motor[backLeft] = 0;
	motor[shooterRight] = 120;
	motor[shooterLeft]  = 120;
	wait1Msec(2650);
	motor[shooterRight] = 0;
	motor[shooterLeft]  = 0;
	motor[intake] = 120;
	motor[rightFront] = 120;
	motor[backRight] = 120;
	motor[leftFront] = 93;
	motor[backLeft] = 93;
	wait1Msec(3000);
	motor[intake] = 0;
	motor[rightFront] = 0;
	motor[backRight] = 0;
	motor[leftFront] = 0;
	motor[backLeft] = 0;
	wait1Msec(1);
	motor[rightFront] = -120;
	motor[backRight] = -120;
	motor[leftFront] = -120;
	motor[backLeft] = -120;
	wait1Msec(500);
	motor[rightFront] = -120;
	motor[backRight] = -120;
	motor[leftFront] = 90;
	motor[backLeft] = 90;
	wait1Msec(675);
	motor[rightFront] = -120;
	motor[backRight] = -120;
	motor[leftFront] = -120;
	motor[backLeft] = -120;
	wait1Msec(800);
	motor[flingerThinger] = 120;
	wait1Msec(500);
	motor[flingerThinger] = 25;
	wait1Msec(500);
	motor[rightFront] = 0;
	motor[backRight] = 0;
	motor[leftFront] = 0;
	motor[backLeft] = 0;
	wait1Msec(1);
	motor[rightFront] = -120;
	motor[backRight] = -120;
	motor[leftFront] = 90;
	motor[backLeft] = 90;
	wait1Msec(1250);
	motor[rightFront] = -120;
	motor[backRight] = -120;
	motor[leftFront] = -120;
	motor[backLeft] = -120;
	wait1Msec(2000);
	motor[rightFront] = 0;
	motor[backRight] = 0;
	motor[leftFront] = 0;
	motor[backLeft] = 0;
	startTask(usercontrol);
}

task coopAutoRed() {
	driveForwardForTime(120, 300);
	wait1Msec(300);
	motor[shooterLeft] = 120;
	motor[shooterRight] = 120;
	driveForwardForTime(120, 2650);
	wait1Msec(2650);
	motor[shooterLeft] = 0;
	motor[shooterRight] = 0;
	driveForwardForTime(-120, 1000);
	wait1Msec(1000);
	turnForTime(120, 500);
	wait1Msec(500);
	driveForwardForTime(-120, 3000);
	motor[flingerThinger] = 120;
	wait1Msec(1000);
	motor[flingerThinger] = 0;
	wait1Msec(2000);
	stopDrive();
}

void pre_auton() {

	bStopTasksBetweenModes = true;
	//used for setting values before auton
}

task autonomous() {
	totalAutonCommands = 7;
	while(lastAutonTask < totalAutonCommands) {
		driveForwardToPosition(2, true, 1);
		driveForwardToPosition(-1, true, 2);
		driveToAngle(45, 120, 3);
		driveForwardToPosition(-1, true, 4);
		driveToAngle(135, 120, 5);
		driveForwardToPosition(-3, true, 6);
		driveForwardToPosition(0, true, 7);
	}
}

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Teleop                                                                     */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task usercontrol() {

	while(true) {
		if((abs(vexRT[Ch2]) >= 0.2)) { //|| (abs(vexRT[Ch1]) >= 0.2)) {
			motor[rightFront] = vexRT[Ch2];// - vexRT[Ch1];
			motor[backRight] = vexRT[Ch2];// - vexRT[Ch1];
			motor[leftFront] = vexRT[Ch3];// - vexRT[Ch1];
			motor[backLeft] = vexRT[Ch3];// - vexRT[Ch1];
			} else {
			motor[rightFront] = 0;
			motor[backRight] = 0;
			motor[leftFront] = 0;
			motor[backLeft] = 0;
		}

		// Prints the encoder values
		writeDebugStreamLine("Right Encoder: %d", SensorValue(PID_SENSOR_INDEX_R));
		writeDebugStreamLine("Left Encoder: %d", SensorValue(PID_SENSOR_INDEX_L));

		//Auton Togglers
		//	-DISABLE At Comp
		if (vexRT[Btn8U] == 1){
			startTask(autonomous);
			stopTask(usercontrol);
		}

		if(vexRT[Btn8R] == 1) {
			startTask(coopAutoBlue);
			stopTask(usercontrol);
		}

		if(vexRT[Btn8L] == 1) {
			startTask(coopAutoRed);
			stopTask(usercontrol);
		}

		if(vexRT[Btn8D] == 1) {
			totalAutonCommands = 3;
			while(lastAutonTask < totalAutonCommands) {
				driveForwardToPosition(1000, true, 1);
				driveToAngle(90, 120, 2);
			}
		}

		if(vexRT[Btn6DXmtr2] == 1) {
			motor[shooterRight] = 120;
			motor[shooterLeft] =  120;
			} else {
			motor[shooterRight] = 0;
			motor[shooterLeft] = 0;
		}

		if(vexRT[Btn5DXmtr2] == 1) {
			motor[flingerThinger] = 60;
			} else if(vexRT[Btn5UXmtr2] == 1) {
			motor[flingerThinger] = -60;
			} else {
			motor[flingerThinger] = 0;
		}

		//intake code
		//BOTH operator AND Driver control the intake
		//Operator overrides the controls

		if(vexRT[Btn7DXmtr2] == 1) {
			motor[intake] = -120;
			motor[elevator] = 120;
			} else if(vexRT[Btn7UXmtr2] == 1) {
			motor[intake] = 120;
			motor[elevator] = -120;
			} else if(vexRT[Btn7RXmtr2] == 1){
			motor[intake] = 0;
			motor[elevator] = 0;
			} else {
			if(vexRT[Btn5D] == 1) {
				motor[intake] = -120;
				motor[elevator] = 120;
				} else if(vexRT[Btn5U] == 1) {
				motor[intake] = 120;
				motor[elevator] = -120;
				} else {
				motor[intake] = 0;
				motor[elevator] = 0;
			}
		}
	}
}




/*****************************/
/*---------------------------*/
/*------ GYROSCOPE CODE -----*/
/*---------------------------*/
/*****************************/

//Source for help: http://www.robotc.net/blog/2011/10/13/programming-the-vex-gyro-in-robotc/


/*****************************/
/*---------------------------*/
/*-------- TEST CODE --------*/
/*---------------------------*/
/*****************************/


/*-- used for driveForwardToPosition method --*/
/*
while(true) {
if(encoderSide) {
currentDist = SensorValue(PID_SENSOR_INDEX_R);
} else if(!encoderSide) {
currentDist = SensorValue(PID_SENSOR_INDEX_L);
}
// Prints the encoder values
writeDebugStreamLine("Right Encoder: %d", SensorValue(PID_SENSOR_INDEX_R));
writeDebugStreamLine("Left Encoder: %d", SensorValue(PID_SENSOR_INDEX_L));
if(currentDist == desiredDist || currentDist >= desiredDist - 40) {
break;
}
wait1Msec(50);
}
*/


/********************/
/* ---------------- */
/* --- OLD CODE --- */
/* ---------------- */
/********************/

/*
//stopTask(pidController);
//stopTask(usercontrol);
//stopTask(shootBall);

/*********************/
/*-------------------*/
/*---- Blue AUTO ----*/
/*-------------------*/
/*********************/
/*
//PID auto
if(SensorValue(autonColorChooser) == 1) {
if(pidRunTimes == 0) {
if(ballShot == 0) {
motor[shooterLeft] = 120;
motor[shooterRight] = 120;
wait1Msec(3500);
ballShot++;
} else {
motor[shooterLeft] = 0;
motor[shooterRight] = 0;
}
driveForwardToPosition(3.5, 3.5);
} else if(pidRunTimes == 1) {
writeDebugStreamLine("---COMMAND 2---");
driveToAngle(90, true);
}
*/





/********************/
/*------------------*/
/*---- Red AUTO ----*/
/*------------------*/
/********************/
/* //PID Auto
} else if(SensorValue(autonColorChooser) == 0) {
if(pidRunTimes == 0) {
if(ballShot == 0) {
motor[shooterLeft] = 120;
motor[shooterRight] = 120;
wait1Msec(3500);
ballShot++;
} else {
motor[shooterLeft] = 0;
motor[shooterRight] = 0;
}
driveForwardToPosition(3.5, 3.5);
} else if(pidRunTimes == 1) {
writeDebugStreamLine("---COMMAND 2---");
driveToAngle(-90, true);
}
}
*/
//Normal Auto
/*

*/


//writeDebugStreamLine("AUTON - STARTED");


/*motor[leftArm] = -100;
motor[rightArm] = -100;
wait1Msec(250);
motor[leftArm] = 100;
motor[rightArm] = 100;
wait1Msec(250);
*/


/*---------------------------------------------*/
