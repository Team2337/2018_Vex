#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  autonColorChooser, sensorTouch)
#pragma config(Sensor, dgtl2,  autonTileChooser, sensorTouch)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftFront,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           elevator,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           shooterRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           shooterLeft,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           flingerThinger, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backRight,     tmotorVex393_HBridge, openLoop)
#pragma config(DatalogSeries, 0, "", Sensors, Sensor, in1, 10)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*******************************************************************/
/* Imports the Debuggar Window,allowing for values to be displayed */
/* while the Robot is running																			 */
/*  !!!!!  MUST HAVE THE USB -> CONTROLLER ADAPTER TO WORK  !!!!!  */
/*******************************************************************/
#pragma platform(VEX2)

#pragma DebuggerWindows("DebugStream")

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"


/*************************/
/* ----- CONSTANTS ----- */
/*************************/


/****************************/
/* ------------------------ */
/* --- GLOBAL VARIABLES --- */
/* ------------------------ */
/****************************/
int distance 	= 0;
int angle		 	= 0;
int speed			= 0;
int direction = 0;

float timeout	= 0;


/*******************/
/* --------------- */
/* --- METHODS --- */
/* --------------- */
/*******************/

void stopDrive() {
	motor[rightFront] = 0;
	motor[leftFront]  = 0;
	motor[backRight]  = 0;
	motor[backLeft]   = 0;
}

void pre_auton() {

	bStopTasksBetweenModes = true;
	//used for setting values before auton
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder]  = 0;
	SensorValue[gyro]					= 0;
}


/*****************/
/* ------------- */
/* --- TASKS --- */
/* ------------- */
/*****************/

task driveToPosition() {
	while(true) {
		if( (abs(SensorValue[rightEncoder]) < distance + 40 && abs(SensorValue[rightEncoder]) > distance - 40) ||
			(abs(SensorValue[leftEncoder])  < distance + 40 && abs(SensorValue[leftEncoder])  > distance - 40) ||
		(abs(SensorValue[gyro]) 			< abs(angle + 40) && abs(SensorValue[gyro]) 			 > abs(angle - 40))){
			stopDrive();
			stopTask(driveToPosition);
			} else {
			motor[rightFront] = speed;// - (distance / angle);
			motor[leftFront]  = speed;// + (distance / angle);
			motor[backRight]  = speed;// - (distance / angle);
			motor[backLeft]   = speed;// + (distance / angle);

		}
	}
}

task turn() {
	while(true) {
		float turn = abs(SensorValue[gyro]);
		if(SensorValue[gyro] > angle) {
			writeDebugStreamLine("AAAAAAAAAAAAAAAAAAAAAAAAAA");
			stopDrive();
			stopTask(turn);

	} else {
		  motor[rightFront] = speed * -direction;
			motor[leftFront]  = speed * direction;
			motor[backRight]  = speed * -direction;
			motor[backLeft]   = speed * direction;
}
}
}

void setPoints(int dist, int degrees, int tSpeed, float timeOut) {
	distance = dist * 1124;
	angle = degrees ;//* 10;
	speed = tSpeed;
	timeout = timeOut;

	startTask(driveToPosition);
}

void setTurn(int degrees, int tSpeed, float timeOut, int d) {
	angle = degrees ;//* 10;
	speed = tSpeed;
	timeout = timeOut;
	direction = d;

	startTask(turn);
}


task autonomous() {
	//setPoints(1, 90, 120, 10);
	setTurn(1000, 120, 10, -1);
	while(true) {
		writeDebugStreamLine("Right Encoder: %d", SensorValue(rightEncoder));
		writeDebugStreamLine("Left Encoder: %d", SensorValue(leftEncoder));
		writeDebugStreamLine("Gyro Ticks: %d", SensorValue[gyro]);
		writeDebugStreamLine("Angle %d", angle);
	}

}


/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Teleop                                                                     */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task usercontrol() {

	while(true) {
		if((abs(vexRT[Ch2]) >= 0.2)) { //|| (abs(vexRT[Ch1]) >= 0.2)) {
			motor[rightFront] = vexRT[Ch2];// - vexRT[Ch1];
			motor[backRight] = vexRT[Ch2];// - vexRT[Ch1];
			motor[leftFront] = vexRT[Ch3];// - vexRT[Ch1];
			motor[backLeft] = vexRT[Ch3];// - vexRT[Ch1];
			} else {
			motor[rightFront] = 0;
			motor[backRight] = 0;
			motor[leftFront] = 0;
			motor[backLeft] = 0;
		}



		if (vexRT[Btn8U] == 1){
			startTask(autonomous);
			stopTask(usercontrol);
		}


		if(vexRT[Btn6DXmtr2] == 1) {
			motor[shooterRight] = 120;
			motor[shooterLeft] =  120;
			} else {
			motor[shooterRight] = 0;
			motor[shooterLeft] = 0;
		}

		if(vexRT[Btn5DXmtr2] == 1) {
			motor[flingerThinger] = 60;
			} else if(vexRT[Btn5UXmtr2] == 1) {
			motor[flingerThinger] = -60;
			} else {
			motor[flingerThinger] = 0;
		}

		//intake code
		//BOTH operator AND Driver control the intake
		//Operator overrights the controls

		if(vexRT[Btn7DXmtr2] == 1) {
			motor[intake] = -120;
			motor[elevator] = 120;
			} else if(vexRT[Btn7UXmtr2] == 1) {
			motor[intake] = 120;
			motor[elevator] = -120;
			} else if(vexRT[Btn7RXmtr2] == 1){
			motor[intake] = 0;
			motor[elevator] = 0;
			} else {
			if(vexRT[Btn5D] == 1) {
				motor[intake] = -120;
				motor[elevator] = 120;
				} else if(vexRT[Btn5U] == 1) {
				motor[intake] = 120;
				motor[elevator] = -120;
				} else {
				motor[intake] = 0;
				motor[elevator] = 0;
			}
		}
	}
}
